#!/usr/local/bin/python3
import argparse
import collections
import configparser
import glob
import os
import subprocess
import sys


default_config_file = '~/.live-backup.cfg'
default_project_dir = os.environ.get('PROJECT_DIR', '~/Projects')


def as_list(v, sep=None):
    return v.strip().split(sep)


def path_type(val):
    val = os.path.expanduser(val)
    return val


arg_parser = argparse.ArgumentParser()
arg_parser.add_argument(
    '--config-file', '-c', type=path_type, default=default_config_file)
arg_parser.add_argument(
    '--list-locations', '-l', action='store_true', default=False,
    help='List available backup locations then exit.')
arg_parser.add_argument('--verbose', '-v', action='store_true', default=False)
arg_parser.add_argument('--dry-run', action='store_true', default=False)
arg_parser.add_argument('--project-dir', '-p', type=path_type, default=None)
arg_parser.add_argument(
    'locations', nargs='*', default=[],
    help='Back up to the specified locations')
args = arg_parser.parse_args()


config_parser = configparser.ConfigParser()
config_parser.read(args.config_file)


available_locations = config_parser.items('available-locations')
available_locations = collections.OrderedDict(
    (k, path_type(v)) for (k, v) in available_locations
)


location_groups = collections.OrderedDict()
if 'location-groups' in config_parser:
    for group, group_locations in config_parser.items('location-groups'):
        group_locations = group_locations.strip().split()
        for group_loc in group_locations:
            if group_loc not in available_locations:
                print('Bad location in {} group: {}'.format(group, group_loc))
                sys.exit(1)
        location_groups[group] = group_locations


def list_available_locations():
    print('Available backup locations:\n')
    for k, v in available_locations.items():
        print('    - {0}: {1}'.format(k, v))
    print('\nLocation groups:\n')
    if location_groups:
        for k, v in location_groups.items():
            print('    - {0}: {1}'.format(k, ', '.join(v)))
    else:
        print('    No location groups')


if args.list_locations:
    list_available_locations()
    sys.exit(0)


if not args.project_dir:
    # Get from config file or fall back to default
    project_dir = config_parser.get(
        'live-backup', 'project-dir', fallback=default_project_dir)
    project_dir = path_type(project_dir)
else:
    project_dir = args.project_dir

section = config_parser['live-backup']
paths_in = {
    '__main__': as_list(section.get('paths', [])),
}
for k, v in section.items():
    if k.startswith('paths.'):
        _, loc = k.split('.', 1)
        paths_in[loc] = as_list(section[k])

excludes = config_parser.get('live-backup', 'excludes')
excludes = as_list(excludes)


# Expand input paths:
#   - project_dir is injected
#   - ~ is expanded
#   - shell style globs are too
paths = {}
for loc, loc_paths in paths_in.items():
    paths[loc] = []
    for i, path in enumerate(loc_paths):
        path = path.format(project_dir=project_dir)
        path = os.path.expanduser(path)
        glob_paths = glob.glob(path)
        paths[loc] += glob_paths
        if not glob_paths:
            print('Path not found: {0}\n'.format(path), file=sys.stderr)


rsync_cmd = ['rsync', '-rltz', '--delete']
if args.dry_run:
    rsync_cmd.append('--dry-run')
if args.verbose:
    rsync_cmd.append('--verbose')
for e in excludes:
    rsync_cmd += ['--exclude', e]


if args.locations:
    selected_locations = []
    for loc in args.locations:
        if loc in location_groups:
            locations = [(l, available_locations[l]) for l in location_groups[loc]]
            selected_locations.extend(locations)
        elif loc in available_locations:
            selected_locations.append((loc, available_locations[loc]))
        else:
            print('{0} is not a valid location key\n'.format(loc))
            list_available_locations()
            sys.exit(1)
else:
    selected_locations = available_locations.values()


for loc, path in selected_locations:
    print("*> Syncing to {0}...".format(path))
    cmd = rsync_cmd[:]
    cmd += paths.get('__main__', [])
    cmd += paths.get(loc, [])
    cmd.append(path)
    print('*> rsync command: {0}\n'.format(' '.join(cmd)))
    return_code = subprocess.call(cmd)
