#!/usr/local/bin/python3
import argparse
import collections
import configparser
import glob
import os
import subprocess
import sys


default_config_file = '~/.live-backup.cfg'
default_project_dir = os.environ.get('PROJECT_DIR', '~/Projects')


def as_list(v, sep='\n'):
    items = v.splitlines() if sep == '\n' else v.split(sep)
    items = [item.strip() for item in items]
    items = [item for item in items if item]
    return items


def path_type(val):
    val = os.path.expanduser(val)
    return val


def exit(*print_args, code=1, file=sys.stderr, sep='\n', **print_kwargs):
    if print_args:
        print(*print_args, file=file, sep=sep, **print_kwargs)
    sys.exit(code)


def debug(*print_args, file=sys.stderr, **print_kwargs):
    if args.debug:
        print('DEBUG', *print_args, file=file, **print_kwargs)


def info(*print_args, file=sys.stdout, **print_kwargs):
    if args.debug or not args.quiet:
        print(*print_args, file=file, **print_kwargs)


def warn(*print_args, file=sys.stderr, **print_kwargs):
    print('WARN', *print_args, file=file, **print_kwargs)


arg_parser = argparse.ArgumentParser()
arg_parser.add_argument(
    '--config-file', '-c', type=path_type, default=default_config_file)
arg_parser.add_argument('--env', '-e', default=None)
arg_parser.add_argument(
    '--list-locations', '-l', action='store_true', default=False,
    help='List available backup locations then exit.')
arg_parser.add_argument(
    '--debug', '-d', action='store_true', default=False,
    help='Show what rsync is doing (add --verbose; print command)')
arg_parser.add_argument(
    '--quiet', '-q', action='store_true', default=False,
    help='Hide default output (show no output unless --debug)')
arg_parser.add_argument(
    '--dry-run', action='store_true', default=False,
    help="Don't actually copy any files (passed through to rsync)")
arg_parser.add_argument('--project-dir', '-p', type=path_type, default=None)
arg_parser.add_argument('--all', '-a', action='store_true', default=False)
arg_parser.add_argument(
    'locations', nargs='*', default=[],
    help='Back up to the specified locations')
args = arg_parser.parse_args()


config_parser = configparser.ConfigParser()
config_parser.read(args.config_file)
section = config_parser['live-backup']

env = args.env or os.getenv('LIVE_BACKUP_ENV') or section.get('env')

available_locations = config_parser.items('available-locations')
available_locations = collections.OrderedDict(
    (k, path_type(v).format(env=env)) for (k, v) in available_locations
)


location_groups = collections.OrderedDict()
if 'location-groups' in config_parser:
    for group, group_locations in config_parser.items('location-groups'):
        group_locations = as_list(group_locations, sep=None)
        for group_loc in group_locations:
            if group_loc not in available_locations:
                exit('Bad location in {} group: {}'.format(group, group_loc))
        location_groups[group] = group_locations


if not args.project_dir:
    # Get from config file or fall back to default
    project_dir = section.get('project-dir', fallback=default_project_dir)
else:
    project_dir = args.project_dir
project_dir = path_type(project_dir)

paths_in = {
    '__main__': as_list(section.get('paths', [])),
}
for k, v in section.items():
    if k.startswith('paths.'):
        _, loc = k.split('.', 1)
        paths_in[loc] = as_list(section[k])

excludes = as_list(section.get('excludes', []))


# Expand input paths:
#   - project_dir is injected
#   - ~ is expanded
#   - shell style globs are too
paths = {}
paths_not_found = []
for loc, loc_paths in paths_in.items():
    paths[loc] = []
    for i, path in enumerate(loc_paths):
        path = path.format(project_dir=project_dir)
        path = os.path.expanduser(path)
        glob_paths = glob.glob(path)
        if not glob_paths:
            paths_not_found.append(path)
        else:
            paths[loc] += glob_paths
if paths_not_found:
    for path in paths_not_found:
        warn('Path not found: {0}'.format(path))
    print()


rsync_cmd = ['rsync', '-rltz', '--delete']
if args.dry_run:
    rsync_cmd.append('--dry-run')
if args.debug:
    rsync_cmd.append('--verbose')
for e in excludes:
    rsync_cmd += ['--exclude', e]


locations = args.locations
default_locations = as_list(section.get('default-locations'), sep=None)
if not locations:
    if not args.all and default_locations:
        locations = default_locations
    else:
        locations = available_locations.keys()

selected_locations = []
for loc in locations:
    if loc in location_groups:
        locations = [(l, available_locations[l]) for l in location_groups[loc]]
        selected_locations.extend(locations)
    elif loc in available_locations:
        selected_locations.append((loc, available_locations[loc]))
    else:
        exit(
            '"{0}" is not a valid location key\n'.format(loc),
            list_available_locations(),
            code=1
        )


def list_available_locations():
    info = ['Available backup locations:\n']
    for k, v in available_locations.items():
        info.append('    - {0}: {1}'.format(k, v))
    info.append('\nLocation groups:\n')
    if location_groups:
        for k, v in location_groups.items():
            info.append('    - {0}: {1}'.format(k, ', '.join(v)))
    else:
        info.append('    No location groups')
    if section.get('default-locations'):
        info.append('\nDefault locations:\n')
        info.append('    - {0}'.format(', '.join(default_locations)))
    info.append('\nProject directory:\n')
    info.append('    - {0}'.format(project_dir))
    return '\n'.join(info)


if args.list_locations:
    exit(list_available_locations(), code=0)


info('Excluded paths:')
for e in excludes:
    info(e)

for loc, dest in selected_locations:
    loc_paths = paths.get('__main__', []) + paths.get(loc, [])
    cmd = rsync_cmd.copy()
    cmd.extend(loc_paths)
    cmd.append(dest)
    debug('{0}'.format(' '.join(cmd)))
    info('Syncing to {0}...'.format(dest))
    info('\n'.join(loc_paths))
    return_code = subprocess.call(cmd)
    info('Finished syncing to {0}'.format(dest))
