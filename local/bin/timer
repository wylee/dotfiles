#!/usr/bin/env python3
"""A simple countdown timer.

Times can be specified in the following formats:

   - S where S > 0
   - M:S where M > 0 and S in [00, 59]
   - H:M:S where H > 0 and M in [00, 59] and S in [00, 59]

"""
import argparse
import re
import sys
import time


DEFAULT_MESSAGE = 'Elapsed: {elapsed} Remaining: {remaining}'
S_RE = r'^(?P<seconds>[1-9]\d*)$'
MS_RE = r'^(?P<minutes>[1-9]\d*):(?P<seconds>[0-5]\d)$'
HMS_RE = r'^(?P<hours>[1-9]\d*):(?P<minutes>[0-5]\d):(?P<seconds>[0-5]\d)$'


def seconds_from_str(arg):
    for pattern in (S_RE, MS_RE, HMS_RE):
        match = re.search(pattern, arg)
        if match is not None:
            break
    else:
        raise ValueError(arg)
    d = match.groupdict()
    h, m, s = d.get('hours', 0), d.get('minutes', 0), d.get('seconds')
    h, m, s = int(h), int(m), int(s)
    seconds = 3600 * h + 60 * m + s
    return seconds


def get_hours_minutes_and_seconds(seconds):
    h, s = divmod(seconds, 3600)
    m, s = divmod(s, 60)
    h, m, s = int(h), int(m), int(round(s))
    return h, m, s


def format_time(seconds_):
    hours, minutes, seconds = get_hours_minutes_and_seconds(seconds_)
    return ':'.join('{:0>2}'.format(p) for p in (hours, minutes, seconds))


def print_message(message, elapsed, remaining):
    format_args = {
        'elapsed': format_time(elapsed),
        'remaining': format_time(remaining),
    }
    sys.stdout.write('\r')
    sys.stdout.write(' ' * 80)
    sys.stdout.write('\r')
    sys.stdout.write(message.format(**format_args))
    sys.stdout.flush()


def run(seconds, message=DEFAULT_MESSAGE, repeat=0, _repeats=0):
    start_time = time.perf_counter()
    for elapsed in range(seconds):
        print_message(message, elapsed, seconds - elapsed)
        # Sleep for ~1 second, adjusting for skew.
        sleep_time = 1 - ((time.perf_counter() - start_time) - elapsed)
        # When the calculated sleep time is less than zero, that
        # indicates that the process has been suspended or slept for
        # longer than expected (longer than 1 second); attempt to "catch
        # up" by not sleeping.
        if sleep_time > 0:
            time.sleep(sleep_time)
    end_time = time.perf_counter()
    real_elapsed = end_time - start_time
    real_remaining = seconds - real_elapsed
    if round(real_remaining) < 0:
        err = '\rError: Timer overran by {:.3f} seconds'.format(-real_remaining)
        sys.stderr.write(err)
    else:
        print_message(message, real_elapsed, 0)
    if _repeats < repeat:
        run(seconds, message, repeat - 1, _repeats + 1)
    sys.stdout.write('\n')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description=__doc__,
            formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('time', type=seconds_from_str, help='[[H:]M:]S')
    parser.add_argument('--repeat', type=int, default=0)
    parser.add_argument(
        '--message', default=DEFAULT_MESSAGE,
        help='Message to display, updated every second; can include format strings: '
             '{elapsed}, {remaining} ["%s"]' % DEFAULT_MESSAGE)
    args = parser.parse_args()
    try:
        run(args.time, args.message, args.repeat)
    except KeyboardInterrupt:
        print_message('Aborted\n', 0, 0)
