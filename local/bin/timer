#!/usr/bin/env python3
"""A simple countdown timer.

Times can be specified in the following formats:

   - S where S > 0
   - M:S where M > 0 and S in [00, 59]
   - H:M:S where H > 0 and M in [00, 59] and S in [00, 59]

"""
import argparse
import re
import sys
import time


DEFAULT_MESSAGE = 'Elapsed: {elapsed} Remaining: {remaining}'
S_RE = r'^(?P<seconds>[1-9]\d*)$'
MS_RE = r'^(?P<minutes>[1-9]\d*):(?P<seconds>[0-5]\d)$'
HMS_RE = r'^(?P<hours>[1-9]\d*):(?P<minutes>[0-5]\d):(?P<seconds>[0-5]\d)$'


def seconds_from_str(arg):
    for pattern in (S_RE, MS_RE, HMS_RE):
        match = re.search(pattern, arg)
        if match is not None:
            break
    else:
        raise ValueError(arg)
    d = match.groupdict()
    h, m, s = d.get('hours', 0), d.get('minutes', 0), d.get('seconds')
    h, m, s = int(h), int(m), int(s)
    seconds = 3600 * h + 60 * m + s
    return seconds


def get_hours_minutes_and_seconds(seconds):
    seconds = round(seconds)
    hours = seconds // 3600
    seconds -= hours * 3600
    minutes = seconds // 60
    seconds -= minutes * 60
    return hours, minutes, seconds


def format_time(seconds_):
    hours, minutes, seconds = get_hours_minutes_and_seconds(seconds_)
    return ':'.join('{:0>2}'.format(p) for p in (hours, minutes, seconds))


def print_message(message, elapsed, remaining):
    format_args = {
        'elapsed': format_time(elapsed),
        'remaining': format_time(remaining),
    }
    sys.stdout.write('\r')
    sys.stdout.write(' ' * 80)
    sys.stdout.write('\r')
    sys.stdout.write(message.format(**format_args))
    sys.stdout.flush()


def run(seconds, message=DEFAULT_MESSAGE, repeat=0, _repeats=0):
    start_time = time.monotonic()
    end_time = start_time + seconds
    elapsed = 0
    remaining = seconds
    sleep_time = 1
    while elapsed <= seconds:
        print_message(message, elapsed, remaining)
        sleep_start_time = time.monotonic()
        time.sleep(sleep_time)
        current_time = time.monotonic()
        actual_sleep_time = current_time - sleep_start_time
        elapsed = current_time - start_time
        remaining = end_time - current_time
        sleep_time = 1 - (actual_sleep_time - 1)
    print_message(message, elapsed, remaining)
    if _repeats < repeat:
        run(seconds, message, repeat - 1, _repeats + 1)
    sys.stdout.write('\n')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description=__doc__,
            formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('time', type=seconds_from_str, help='[[H:]M:]S')
    parser.add_argument('--repeat', type=int, default=0)
    parser.add_argument(
        '--message', default=DEFAULT_MESSAGE,
        help='Message to display, updated every second; can include format strings: '
             '{elapsed}, {remaining} ["%s"]' % DEFAULT_MESSAGE)
    args = parser.parse_args()
    try:
        run(args.time, args.message, args.repeat)
    except KeyboardInterrupt:
        print_message('Aborted\n', 0, 0)
