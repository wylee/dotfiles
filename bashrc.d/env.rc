RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
BLUE="$(tput setaf 4)"
RESET="$(tput sgr 0)"
VENV_DIR=".env"
VENV_BIN="${VENV_DIR}/bin"
NODE_DIR="node_modules"
NODE_BIN="${NODE_DIR}/.bin"

function cd {
    builtin cd "$@"
    if [ "$PWD" = "$HOME" ]; then
        deactivateenv
    elif [ -f "${VENV_BIN}/python" ]; then
        activateenv
    fi
}

function cdenv {
    # Args:
    #     env_dir: A subdirectory of $PROJECT_DIR [optional]
    #
    # If env_dir is passed (as $1), cd into $PROJECT_DIR/$env_dir and
    # then activate the virtualenv in that directory.
    #
    # If env_dir isn't passed, cd into the current env directory.
    if [ -n "${1}" ]; then
        local env_dir="${PROJECT_DIR}/${1}"
    elif [ -n "${_ENV_CURRENT}" ]; then
        local env_dir="${_ENV_CURRENT}"
    fi
    if [ -n "${env_dir}" ]; then
        builtin cd "${env_dir}"
        activateenv
    else
        echo "${RED}No env passed and no env is already active${RESET}" 1>&2
        deactivateenv
    fi
}

function activateenv {
    local env_type

    if [ -f "${VENV_BIN}/python" ]; then
        env_type="virtualenv"
    elif [ -d "${NODE_DIR}" ]; then
        env_type="node"
    else
        if [ "$1" != "silent" ]; then
            echo "${RED}This is not an env directory${RESET}" 1>&2
            deactivateenv
        fi
        return
    fi

    # Do nothing if this virtualenv is already active
    if [ -n "$_ENV_CURRENT" ] && [ "$PWD" = "$_ENV_CURRENT" ]; then
        return
    fi

    deactivateenv

    export PROJECT_NAME="$(basename $PWD)"
    export _ENV_CURRENT="$PWD"
    export _ENV_ORIGINAL_PATH="$PATH"

    if [ "$env_type" = "virtualenv" ]; then
        if [ -d "${NODE_BIN}" ]; then
            export PATH="${PWD}/${NODE_BIN}:${PATH}"
        elif [ -d "${PROJECT_NAME}/static/${NODE_BIN}" ]; then
            export PATH="${PWD}/${PROJECT_NAME}/static/${NODE_BIN}:${PATH}"
        fi
        export PATH="${PWD}/${VENV_BIN}:${PATH}"
    elif [ "$env_type" = "node" ]; then
        export PATH="${PWD}/${NODE_BIN}:${PATH}"
    fi

    hash -r 2>/dev/null
    echo -e "${GREEN}Activated ${_ENV_CURRENT} (${env_type}) ${RESET}"
}

function deactivateenv {
    if [ -n "$_ENV_CURRENT" ]; then
        local env_current="$_ENV_CURRENT"
        unset PROJECT_NAME
        unset _ENV_CURRENT
        export PATH="$_ENV_ORIGINAL_PATH"
        unset _ENV_ORIGINAL_PATH
        hash -r 2>/dev/null
        echo -e "${RED}Deactivated ${env_current}${RESET}"
    fi
}

# Brown noise
function bn {
    local pid_file="${HOME}/.brown-noise.pid"
    if [ -f "$pid_file" ]; then
        kill -s kill $(cat "$pid_file")
        rm "$pid_file"
    else
        AUDIODEV="Built-in Output" \
            play -q -c 2 --null \
                synth brownnoise \
                band -n 1500 1500 \
                tremolo .0333333 30 \
                reverb &
        local PID=$!
        echo -n $PID > "$pid_file"
    fi
}

function _complete_cdenv {
    local cmd="$1"
    local current="$2"
    local IFS='
'
    local candidate
    local candidate_basename
    COMPREPLY=()
    for path in "${PROJECT_DIR}/${current}"*/; do
        candidate_basename="$(basename ${path})"
        if [ -d "$path" ] && [[ ! "$candidate_basename" =~ ^[._] ]]; then
            candidate="${path#${PROJECT_DIR}/}"
            COMPREPLY+=("$candidate")
        fi
    done
}
complete -F _complete_cdenv -o filenames -o nospace cdenv


# Invoke (pyinvoke.org) tab-completion script to be sourced with Bash shell.
# Known to work on Bash 3.x, untested on 4.x.
_complete_invoke() {
    local candidates

    # COMP_WORDS contains the entire command string up til now (including
    # program name).
    # We hand it to Invoke so it can figure out the current context: spit back
    # core options, task names, the current task's options, or some combo.
    candidates=`invoke --complete -- ${COMP_WORDS[*]}`

    # `compgen -W` takes list of valid options & a partial word & spits back
    # possible matches. Necessary for any partial word completions (vs
    # completions performed when no partial words are present).
    #
    # $2 is the current word or token being tabbed on, either empty string or a
    # partial word, and thus wants to be compgen'd to arrive at some subset of
    # our candidate list which actually matches.
    #
    # COMPREPLY is the list of valid completions handed back to `complete`.
    COMPREPLY=( $(compgen -W "${candidates}" -- $2) )
}
# Tell shell builtin to use the above for completing 'inv'/'invoke':
# * -F: use given function name to generate completions.
# * -o default: when function generates no results, use filenames.
# * positional args: program names to complete for.
complete -F _complete_invoke -o default invoke inv
